<?php

namespace LaraMake\Console\Commands\Abstracts;

use LaraMake\Console\Commands\Traits\Replace\ReplaceMethodTrait;
use LaraMake\Console\Commands\Traits\Replace\ReplacePropertyTrait;
use LaraMake\Console\Commands\Traits\TemplatesTrait;

abstract class InterfaceMaker extends PhpMaker
{
    use ReplacePropertyTrait, ReplaceMethodTrait, TemplatesTrait;

    /**
     * @var string
     */
    public $instance = 'interface';

    /**
     * @var array
     */
    public $keyWords = [
        'namespace',
        'use',
        'pattern',
        'parents',
        'constant',
        'method',
    ];

    public $processKeyWordBackSlashParts = [
        'pattern' => 'ucfirst'
    ];

    public $processKeyWordSuffix= [
        'pattern' => 'Interface'
    ];

    public $parents;
    protected $__parents;
    protected $__constant;
    protected $__method;

    /**
     * Make BaseTemplate which all templates must be extend
     *
     * @var
     */
    public $makeBase = false;

    /**
     * If basePattern not defined that case basePattern property will automatically created
     *  basePattern = basePrefix .  patternInstance
     *
     * @var string
     */
    public $basePrefix = 'Base';

    /**
     * If has parent basePattern must be extend parent
     * Base pattern name which all class must be extends
     *
     * @var
     */
    public $basePattern;

    public $rootPath = 'app' . DIRECTORY_SEPARATOR . 'Repositories' . DIRECTORY_SEPARATOR . 'Contracts';

    /**
     * @var string
     */
    public $stub = 'interface.stub';


    /**
     * @param $patterns
     * @param $stubContent
     * @return bool
     */
    public function fillPatterns($patterns, $stubContent)
    {
        if ($this->makeBase) {
            if (false == $this->createBasePattern($stubContent)) {
                // @TODO show dont saved message
                return false;
            }
        }
        return parent::fillPatterns($patterns, $stubContent); // TODO: Change the autogenerated stub
    }

    /**
     * @param $stubContent
     * @return int|null
     */
    public function createBasePattern($stubContent)
    {
        $basePattern = $this->getBasePattern();
        $result = $this->createFileBy($basePattern, $stubContent);

        if ($result) {
            $this->__use = [];
            $this->__method = [];
            $this->__parents = $this->__namespace . DIRECTORY_SEPARATOR . $basePattern;
        }

        return $result;
    }

    public function getBasePatternFullName()
    {
        return $this->getRelativePath() . $this->getBasePattern();
    }

    /**
     * @return string
     */
    public function getBasePattern()
    {
        if ($this->basePattern) {
            return $this->basePattern;
        }

        return ucfirst($this->basePrefix) . ucfirst($this->instance);
    }

    /**
     * @param $content
     * @param $keyWord
     * @param $input
     * @return mixed
     */
    public function replacePatternKeyWord($content, $keyWord, $input)
    {
        if (strpos($input, DIRECTORY_SEPARATOR)) {
            $input = last(explode(DIRECTORY_SEPARATOR, $input));
        }

        return str_replace($keyWord, $input, $content);
    }

    /**
     * @param $content
     * @param $keyWord
     * @param $input
     * @return mixed
     */
    public function replaceParentsKeyWord($content, $keyWord, $input)
    {
        $parents = $input ?? $this->parents;
        $parents = (array) $parents;
        if (empty($parents)) {
            return str_replace(' ' . $keyWord, '', $content);
        }

        $baseNames = [];
        foreach ($parents as $parent) {
            $baseNames[] = $this->getNamespaceBaseName($parent, $this->__use);

        }
        $to = sprintf('extends %s', implode(', ', $baseNames));
        return str_replace($keyWord, $to, $content);
    }

    /**
     * @param $content
     * @param $keyWord
     * @param $input
     * @return mixed
     */
    public function replaceConstantKeyWord($content, $keyWord, $input)
    {
        $input = (array) $input;
        // @TODO generalize it and processInputIsArray check in dynamicallyParseOptionInput

        $template = "const %s = '%s';" . PHP_EOL . PHP_EOL . TAB;
        $str = '';
        foreach ($input as $constant => $value) {
            $str .= sprintf($template, $constant, $value);
        }

        if (empty($str)) {
            return str_replace(PHP_EOL .TAB . $keyWord . PHP_EOL, '', $content);
        }

        $str = rtrim($str, PHP_EOL . PHP_EOL . TAB);

        return str_replace($keyWord , $str, $content);
    }

    public function trimUseKeyWord($content, $keyWord)
    {
        return parent::trimUseKeyWord($content, $keyWord); // TODO: Change the autogenerated stub
    }

    public function trimFinalContent($content)
    {
        $content = str_replace_last(PHP_EOL . '{}'. PHP_EOL, PHP_EOL . '{' . PHP_EOL . TAB . PHP_EOL . '}'. PHP_EOL, $content);
        return parent::trimFinalContent($content);
    }
}
